#!/usr/bin/env tsx
/**
 * Croatian Law MCP -- Census-Driven Ingestion Pipeline
 *
 * Fetches Croatian legislation from Narodne novine ELI endpoints.
 * Downloads the print HTML page for each law and parses structured provisions.
 *
 * **Census-driven**: Reads data/census.json (generated by scripts/census.ts) to
 * enumerate ALL Croatian laws. Falls back to hardcoded TARGET_LAWS if census is missing.
 *
 * Usage:
 *   npm run ingest                    # Full ingestion (from census)
 *   npm run ingest -- --limit 5       # Test with 5 laws
 *   npm run ingest -- --skip-fetch    # Reuse cached pages
 *   npm run ingest -- --resume        # Skip laws that already have seed files
 *
 * Source: Narodne novine (narodne-novine.nn.hr) ELI endpoints
 * License: Croatian Government Open Data (public domain under Copyright Act Art. 8)
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import { fetchWithRateLimit } from './lib/fetcher.js';
import {
  TARGET_LAWS,
  parseCroatianEliHtml,
  type LawTarget,
  type ParsedLaw,
} from './lib/parser.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SOURCE_DIR = path.resolve(__dirname, '../data/source');
const SEED_DIR = path.resolve(__dirname, '../data/seed');
const CENSUS_PATH = path.resolve(__dirname, '../data/census.json');

/* ------------------------------------------------------------------ */
/*  Census types                                                       */
/* ------------------------------------------------------------------ */

interface CensusLaw {
  id: string;
  title: string;
  year: number;
  issue: number;
  act_num: string;
  type: string;
  url: string;
  classification: 'ingestable' | 'inaccessible' | 'metadata_only' | 'correction_notice';
}

interface CensusData {
  generated_at: string;
  stats: {
    total: number;
    class_ingestable: number;
    class_inaccessible: number;
    class_metadata_only: number;
    class_correction_notice: number;
  };
  ingestion?: {
    completed_at: string;
    total_laws: number;
    total_provisions: number;
    coverage_pct: string;
  };
  laws: CensusLaw[];
}

/* ------------------------------------------------------------------ */
/*  CLI args                                                           */
/* ------------------------------------------------------------------ */

interface CliArgs {
  limit: number | null;
  skipFetch: boolean;
  resume: boolean;
}

function parseArgs(): CliArgs {
  const args = process.argv.slice(2);
  let limit: number | null = null;
  let skipFetch = false;
  let resume = false;

  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--limit' && args[i + 1]) {
      limit = Number.parseInt(args[i + 1], 10);
      i++;
    } else if (args[i] === '--skip-fetch') {
      skipFetch = true;
    } else if (args[i] === '--resume') {
      resume = true;
    }
  }

  return { limit, skipFetch, resume };
}

/* ------------------------------------------------------------------ */
/*  Census -> LawTarget conversion                                     */
/* ------------------------------------------------------------------ */

function censusLawToTarget(law: CensusLaw): LawTarget {
  return {
    seedFile: `${law.id}.json`,
    id: law.id,
    title: law.title,
    titleEn: law.title, // Croatian title used as fallback for English
    shortName: law.title.length > 60 ? law.title.substring(0, 57) + '...' : law.title,
    year: law.year,
    issue: law.issue,
    actNum: law.act_num,
    status: 'in_force',
    description: `Zakon objavljen u Narodnim novinama (${law.year}/${law.issue}/${law.act_num}), preuzet putem ELI sucelja.`,
  };
}

/**
 * Load acts from census.json if available, otherwise fall back to TARGET_LAWS.
 */
function loadActList(): LawTarget[] {
  if (fs.existsSync(CENSUS_PATH)) {
    const raw = fs.readFileSync(CENSUS_PATH, 'utf-8');
    const census = JSON.parse(raw) as CensusData;

    console.log(`  Census: ${census.stats.total} laws (generated ${census.generated_at})`);

    // Only include ingestable laws (skip correction notices, inaccessible, etc.)
    const ingestable = census.laws.filter(l => l.classification === 'ingestable');
    console.log(`  Ingestable: ${ingestable.length} laws`);

    return ingestable.map(censusLawToTarget);
  }

  console.log('  WARNING: No census.json found -- falling back to TARGET_LAWS (10 laws)');
  console.log('  Run: npx tsx scripts/census.ts   to generate full census\n');
  return TARGET_LAWS;
}

/* ------------------------------------------------------------------ */
/*  Fetch + parse                                                      */
/* ------------------------------------------------------------------ */

async function fetchHtml(target: LawTarget, skipFetch: boolean): Promise<string> {
  const sourceFile = path.join(SOURCE_DIR, `${target.id}.html`);

  if (skipFetch && fs.existsSync(sourceFile)) {
    return fs.readFileSync(sourceFile, 'utf-8');
  }

  const url = `https://narodne-novine.nn.hr/eli/sluzbeni/${target.year}/${target.issue}/${target.actNum}/hrv/printhtml`;
  const result = await fetchWithRateLimit(url);

  if (result.status !== 200) {
    throw new Error(`HTTP ${result.status} for ${url}`);
  }

  if (result.body.includes('Sadrzaj je nedostupan') || result.body.includes('Sadr≈æaj je nedostupan')) {
    throw new Error(`No content for ${url}`);
  }

  fs.writeFileSync(sourceFile, result.body);
  return result.body;
}

/* ------------------------------------------------------------------ */
/*  Main ingestion loop                                                */
/* ------------------------------------------------------------------ */

async function run(targets: LawTarget[], skipFetch: boolean, resume: boolean): Promise<void> {
  fs.mkdirSync(SOURCE_DIR, { recursive: true });
  fs.mkdirSync(SEED_DIR, { recursive: true });

  let processed = 0;
  let resumed = 0;
  let failed = 0;
  let totalProvisions = 0;
  let totalDefinitions = 0;
  const startTime = Date.now();

  const report: { law: string; provisions: number; definitions: number; status: string }[] = [];

  for (const target of targets) {
    const seedFile = path.join(SEED_DIR, target.seedFile);

    // Resume support: skip laws that already have seed files
    if (resume && fs.existsSync(seedFile)) {
      try {
        const existing = JSON.parse(fs.readFileSync(seedFile, 'utf-8')) as ParsedLaw;
        totalProvisions += existing.provisions.length;
        totalDefinitions += existing.definitions.length;
        resumed++;
        processed++;
        continue;
      } catch {
        // If seed file is corrupt, re-ingest
      }
    }

    try {
      let html: string;

      if (fs.existsSync(path.join(SOURCE_DIR, `${target.id}.html`)) && skipFetch) {
        html = fs.readFileSync(path.join(SOURCE_DIR, `${target.id}.html`), 'utf-8');
      } else {
        process.stdout.write(`  [${processed + 1}/${targets.length}] Fetching ${target.id}...`);
        html = await fetchHtml(target, skipFetch);
        console.log(` OK (${(html.length / 1024).toFixed(0)} KB)`);
      }

      const parsed = parseCroatianEliHtml(html, target);

      if (parsed.provisions.length === 0) {
        throw new Error('Parsed 0 provisions');
      }

      fs.writeFileSync(seedFile, JSON.stringify(parsed, null, 2) + '\n');

      totalProvisions += parsed.provisions.length;
      totalDefinitions += parsed.definitions.length;

      report.push({
        law: target.shortName,
        provisions: parsed.provisions.length,
        definitions: parsed.definitions.length,
        status: 'OK',
      });

      process.stdout.write(`    -> ${parsed.provisions.length} provisions, ${parsed.definitions.length} definitions\n`);
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      console.log(`  ERROR parsing ${target.shortName}: ${msg}`);
      report.push({ law: target.shortName, provisions: 0, definitions: 0, status: `ERROR: ${msg}` });
      failed++;
    }

    processed++;

    // Progress log every 50 laws
    if (processed % 50 === 0) {
      const elapsed = ((Date.now() - startTime) / 1000).toFixed(0);
      const eta = ((Date.now() - startTime) / processed * (targets.length - processed) / 1000).toFixed(0);
      console.log(`\n  --- Progress: ${processed}/${targets.length} (${elapsed}s elapsed, ~${eta}s remaining) ---\n`);
    }
  }

  const totalElapsed = ((Date.now() - startTime) / 1000).toFixed(1);

  // Print summary
  console.log(`\n${'='.repeat(70)}`);
  console.log('INGESTION REPORT');
  console.log('='.repeat(70));

  if (report.length <= 100) {
    console.log(`${'Law'.padEnd(40)} ${'Prov'.padEnd(8)} ${'Defs'.padEnd(8)} Status`);
    console.log('-'.repeat(70));
    for (const r of report) {
      console.log(
        `${r.law.substring(0, 39).padEnd(40)} ${String(r.provisions).padEnd(8)} ${String(r.definitions).padEnd(8)} ${r.status}`
      );
    }
    console.log('-'.repeat(70));
  } else {
    const okCount = report.filter(r => r.status === 'OK').length;
    const failedCount = report.filter(r => r.status !== 'OK').length;
    console.log(`  New ingestions:  ${okCount}`);
    console.log(`  Failed:          ${failedCount}`);
    if (failedCount > 0) {
      console.log('\n  Failed laws:');
      for (const r of report.filter(r => r.status !== 'OK').slice(0, 30)) {
        console.log(`    ${r.law.substring(0, 55).padEnd(56)} ${r.status}`);
      }
      if (failedCount > 30) {
        console.log(`    ... and ${failedCount - 30} more`);
      }
    }
  }

  console.log(`\n${'='.repeat(70)}`);
  console.log(`  Total elapsed:     ${totalElapsed}s`);
  console.log(`  Laws processed:    ${processed}`);
  console.log(`  Laws resumed:      ${resumed}`);
  console.log(`  Laws failed:       ${failed}`);
  console.log(`  Total provisions:  ${totalProvisions}`);
  console.log(`  Total definitions: ${totalDefinitions}`);

  // Update census.json with ingestion stats
  if (fs.existsSync(CENSUS_PATH)) {
    const census = JSON.parse(fs.readFileSync(CENSUS_PATH, 'utf-8')) as CensusData;
    census.ingestion = {
      completed_at: new Date().toISOString(),
      total_laws: processed - failed,
      total_provisions: totalProvisions,
      coverage_pct: ((processed - failed) / targets.length * 100).toFixed(1),
    };
    fs.writeFileSync(CENSUS_PATH, JSON.stringify(census, null, 2) + '\n');
    console.log(`\n  Updated census.json with ingestion stats.`);
  }
}

async function main(): Promise<void> {
  const { limit, skipFetch, resume } = parseArgs();

  console.log('Croatian Law MCP -- Ingestion Pipeline');
  console.log('======================================\n');
  console.log(`  Source:  Narodne novine (narodne-novine.nn.hr)`);
  console.log(`  Method:  ELI print HTML`);
  console.log(`  License: Croatian Government Open Data (public domain)`);

  if (limit) console.log(`  --limit ${limit}`);
  if (skipFetch) console.log(`  --skip-fetch`);
  if (resume) console.log(`  --resume (skip existing seed files)`);

  const allTargets = loadActList();
  const targets = limit ? allTargets.slice(0, limit) : allTargets;
  await run(targets, skipFetch, resume);
}

main().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
});
